<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>PDF to Figma</title>
  <link rel="stylesheet" href="style.css">
  <style>
    body { font-family: Arial, sans-serif; padding: 24px; }
    input[type=file] { margin-bottom: 16px; }
    button { padding: 8px 16px; }
  </style>
  <script src="https://unpkg.com/pdfjs-dist@3.11.174/build/pdf.min.js"></script>
</head>
<body>
  <h2>Importar PDF</h2>
  <input type="file" id="pdf-input" accept="application/pdf" />
  <button id="import-btn">Importar</button>
  <script>
    document.getElementById('import-btn').onclick = async () => {
      const input = document.getElementById('pdf-input');
      if (input.files.length === 0) {
        parent.postMessage({ pluginMessage: { type: 'error', message: 'Selecione um arquivo PDF.' } }, '*');
        return;
      }
      const file = input.files[0];
      const arrayBuffer = await file.arrayBuffer();
      let pdf;
      try {
        pdf = await window['pdfjsLib'].getDocument({ data: arrayBuffer }).promise;
      } catch (err) {
        parent.postMessage({ pluginMessage: { type: 'error', message: 'Erro ao carregar o PDF. Tente outro arquivo ou verifique o formato.' } }, '*');
        return;
      }
      function extractParagraphs(items) {
        items.sort((a, b) => {
          const yDiff = a.y - b.y; // CORREÇÃO: de cima para baixo
          if (Math.abs(yDiff) > 1) return yDiff;
          return a.x - b.x; // da esquerda para a direita
        });
        const paragraphs = [];
        let currentParagraph = '';
        let lastItem = null;
        let paragraphY = items.length > 0 ? items[0].y : 0;
        let paraItems = [];
        for (const item of items) {
          if (lastItem) {
            const lastY = lastItem.y;
            const currentY = item.y;
            const yDifference = Math.abs(currentY - lastY);
            if (yDifference > (lastItem.height * 1.5)) {
              paragraphs.push({ text: currentParagraph.trim(), y: paragraphY, fontSize: lastItem.fontSize, items: paraItems });
              currentParagraph = '';
              paragraphY = currentY;
              paraItems = [];
            } else if (item.x < lastItem.x) {
              currentParagraph += '\n';
            }
          }
          currentParagraph += item.str + ' ';
          paraItems.push({ x: item.x, width: item.width });
          lastItem = item;
        }
        if (currentParagraph.trim() !== '') {
          paragraphs.push({ text: currentParagraph.trim(), y: paragraphY, fontSize: lastItem ? lastItem.fontSize : 12, items: paraItems });
        }
        return paragraphs;
      }
      for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
        let page, viewport, textContent;
        try {
          page = await pdf.getPage(pageNum);
          viewport = page.getViewport({ scale: 1 });
          textContent = await page.getTextContent();
        } catch (err) {
          parent.postMessage({ pluginMessage: { type: 'error', message: `Erro ao processar página ${pageNum}.` } }, '*');
          continue;
        }
        const items = textContent.items.map(item => ({
          str: item.str,
          x: item.transform[4],
          y: viewport.height - item.transform[5],
          fontSize: item.transform[0],
          width: item.width,
          height: item.height,
          hasEOL: item.hasEOL
        }));
        const paragraphs = extractParagraphs(items);
        parent.postMessage({
          pluginMessage: {
            type: 'import-pdf-layout',
            pdfWidth: viewport.width,
            pdfHeight: viewport.height,
            paragraphs,
            pageNum
          }
        }, '*');
      }
    };
  </script>
</body>
</html>
